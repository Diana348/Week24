# Week24
1. Кратко опишите основные отличия `state` от `props`.
state​ - структура данных, необходимая для изменения и отслеживания 
пользовательских действий. 
props​ - набор конфигурации, поступающий от родительского элемента. Их нельзя 
изменять.

2. Какую ошибку я допустила в следующем коде и как её исправить:
    handleChange = () => {
        const chechedArr = this.state.arr; // [1,2,3] 
    		chechedArr.push(5); // [1,2,3,5] 
        this.setState({
          arr: chechedArr,
        });
      };
      
ошибки нет

3. Можно ли повесить на один элемент несколько обработчиков событий?
Можно

4. Каким образом можно изменить `state`?
Constructor() - место, где state может изменяться напрямую (в классовых компонентах)
setStae () - метод (хук) принимает объект, объединяя его с текущим состоянием (в функциональных компонентах)

5. Попробуйте предсказать, какие сообщения будут в консоли, и объяснить результат:
    handleChange = () => {
        console.log(this.state.checked) //#1 false 
        this.setState({
          checked: !this.state.checked, //true
        });
        console.log(this.state.checked) //#2 false
      };  

6. Какими способами можно задать функцию `handleChange` и какой из них является самым правильным?
handleChange() {
    const { checked } = this.state;
    this.setState({ checked: !checked });
  };

  handleChange = () => {
    this.setState({
      checked: !this.state.checked,
    });
  };
Правильнее использовать стрелочные функции.

7. Чем отличаются классовые и функциональные компоненты? Какие из них предпочтительнее в 2021 году?
Функциональные компонентыы:
Компонент принимает объект props, в котором содержаться значения переданные от родительского компонента. В props можно передавать любые типы, даже другие компоненты. 
Функциональный компонент возвращает React-элемент. Он должен быть только один, если их больше, они должны быть обернуты родителем.

Классовые компоненты:
Главное отличие классового компонента от функционального это возможность хранить внутреннее состояния.
Классовый компонент должен содержать метод render(), который возвращает React-элемент. Доступ к props осуществляется через this.props. Обновление компонента происходит при изменении пропсов или состояния. 
Чтобы получить возможность устанавливать state, нужно определить конструктор и вызвать метод super(), в конструктор и super передаются props. Само состояние изначально определяется в this.state, больше напрямую изменять state нельзя, это может привести к непредсказуемым последствиям.

Сейчас предпочтительнее использовать функциональные компоненты (они короче пишутся и корректнее работают)


8. Есть ли `this` в функциональных компонентах? Как можно получить доступ к нему?
нет

9. Можно ли использовать `props` и `state` одновременно?
Можно, они могут испоьзоваться вместе, так и по-отдельности или вообще не использоваться.

10. Где можно задать `state` без использования команды `this.setState`?
const [checked, setChecked] = useState(props.checked || false);

11. Может ли состояние классового компонента не быть объектом? А функционального?
у классового компонента - объект, а у функционального как объект так и нет.

12. Способны ли функциональные компоненты самостоятельно хранить состояние?
да, а изменять его могут только с помощью хуков.

13. Как использовать хуки в классовых компонентах?
переменная count хранит состояние, а функция setsetCount() позволяет изменять значение count. Единственный аргумент useState() — это начальное состояние. Исходное значение аргумента используется только при первом рендере.
import React, {useState} from 'react';

export default function Clicker() {
    // сохраняем состояние в переменной count
    const [count, setCount] = useState(0);

    const handleMinusClick = () => {
        setCount(count - 1);
    };

    const handlePlusClick = () => {
        setCount(count + 1);
    };

    return (
        <div>
            <button onClick={handleMinusClick}>minus</button>
            <strong>{count}</strong>
            <button onClick={handlePlusClick}>plus</button>
        </div>
    );
}

14. А как задать начальное состояние `props`, если они ещё не были переданы?
static defaultProps = {
		name: 'Hello!',
	};
    или
    const name = this.props.name || 'Hello!';